<!DOCTYPE HTML>
<!--
Jasmine Rodriguez
CAP4730
Assignment 10 Spooky Dark Forest
Last modified: 4/17/24
-->
<HTML lang="en">
	<Head>
	<Title>"Spoopy Forest"</TITLE>
		
		<script id="2dVertexShader" type="notjs">
			precision mediump float;
		
			attribute vec4 a_position;	
			attribute vec3 vert_color;
			varying vec3 fragColor;		

			uniform vec3 transform;
			uniform vec3 rotation;		
			uniform vec3 scale;
			
			//This was added for camera move
			uniform vec3 cameraLoc;
			uniform vec3 cameraRotation;
			uniform float n;
			uniform float f;
			uniform float r;
			uniform float t;
			
			// Lighting
			varying vec3 fakenormal;
			varying vec3 v_surfaceToLight;
			varying vec3 v_surfaceToView;
			
			// Point light set up
			varying vec3 v_surfacePos;		
			uniform vec3 p_lightPos[8];
			
			// Spot light set up
			varying vec3 v_spot_surfaceToLight;
			uniform vec3 v_spot_light_pos;
			uniform vec3 v_spot_light_direction;
			
			uniform mediump vec3 moonDirection;
		
			vec4 PositionObject(vec4 pos)
			{
				mat4 translateM = mat4(1.0,0.0,0.0,0.0,
							0.0,1.0,0.0,0.0,
							0.0,0.0,1.0,0.0,
							transform.x,transform.y,transform.z,1.0);
				return translateM*pos;	
			}

			vec4 ScaleObject (vec4 pos)
			{
				if (length(scale) != 0.0)
				{
					mat4 scaleM = mat4(
						scale.x, 0.0, 0.0, 0.0,
						0.0, scale.y, 0.0, 0.0,
						0.0, 0.0, scale.z, 0.0,
						0.0, 0.0, 0.0, 1.0
					);	
					return scaleM*pos;
				}
				else 
				{
					return pos;
				}
			}
			
			vec4 RotateObject (vec4 pos)
			{
				vec3 c = cos(rotation);
				vec3 s = sin(rotation);
				mat4 rotateX = mat4 (
					1.0,	0.0,	0.0,	0.0,
					0.0,	c.x,	s.x,	0.0,
					0.0,	-1.0*s.x,	c.x,	0.0,
					0.0,	0.0,	0.0,	1.0
				);

				mat4 rotateY = mat4(
					c.y,	0.0,	-1.0*s.y,	0.0,
					0.0,	1.0,	0.0,	0.0,
					s.y,	0.0,	c.y,	0.0,
					0.0,	0.0,	0.0,	1.0
				);

				mat4 rotateZ = mat4(
				c.z,	s.z,	0.0,	0.0,
				-1.0*s.z,	c.z,	0.0,	0.0,
				0.0,	0.0,	1.0,	0.0,
				0.0,	0.0,	0.0,	1.0
				);

				return rotateX * rotateY * rotateZ * pos;
			}		

			vec4 MoveCamera(vec4 pos)
			{
				vec3 cw = cos(cameraRotation);
				vec3 sw = sin(cameraRotation);
				
				mat4 translateView = mat4(
							1.0,0.0,0.0,0.0,
							0.0,1.0,0.0,0.0,
							0.0,0.0,-1.0,0.0,
							-1.0*cameraLoc.x,-1.0*cameraLoc.y,cameraLoc.z,1.0
							);
							
				mat4 rotateYView = mat4(
							cw.y,0.0,-1.0*sw.y,0.0,
							0.0,1.0,0.0,0.0,
							sw.y,0.0,cw.y,0.0,
							0.0,0.0,0.0,1.0
							);
										
				mat4 rotateXView = mat4(
							1.0,	0.0,		0.0,	0.0,
							0.0,	cw.x,		sw.x,	0.0,
							0.0,	-1.0*sw.x, 	cw.x,	0.0,
							0.0,	0.0,		0.0,	1.0
									);
				
				mat4 rotateZView = mat4(
							cw.z,		sw.z,		0.0,	0.0,
							-1.0*sw.z, 	cw.z,		0.0,	0.0,
							0.0,		0.0,		1.0,	0.0,
							0.0,		0.0,		0.0,	1.0
									);		
				return rotateXView*rotateYView*rotateZView*translateView*pos;
			}
			
			vec4 ApplyProjection(vec4 pos)
			{
			
				mat4 ComplexPerspective = mat4(
					n/r, 0.0,0.0,0.0,
					0.0, n/t,0.0,0.0,
					0.0, 0.0, -1.0*(f+n)/(f-n), -1.0,
					0.0, 0.0, -2.0*f*n/(f-n), 0.0
					);
											
				mat4 ComplexOrtho = mat4(	
					1.0/r, 0.0, 0.0, 0.0,
					0.0, 1.0/t, 0.0, 0.0,	
					0.0, 0.0, 1.0, 0.0,
					-1.0, 1.0, 0.0, 1.0	
					);
								
				//Choose which projection you want here:  Perspective or Orthographic			
				return ComplexPerspective*pos;
			}					
			
			//End of Camera Move			
			
			vec4 LookAt(vec3 F, vec3 U, vec4 pos)
			{
				//precision mediump float;
				vec3 R = cross(F,U);
				mat4 LookAt = mat4(
					R.x,R.y,R.z,0.0,
					U.x,U.y,U.z,0.0,
					F.x,F.y,F.z,0.0,
					0.0,0.0,0.0,1.0
				);
						
				return LookAt*pos;	
			}
			

			void main()
			{
				if (length(a_position) < 5.0)
					fakenormal = RotateObject(a_position).xyz;
				else 
					fakenormal = vec3(0.0, 1.0, 0.0);

				vec4 worldSpace = PositionObject(RotateObject(a_position));

				// Lighting Stuff
				v_surfaceToLight = vec3(0.0, 0.0, -5.0) - worldSpace.xyz;
				v_surfaceToView = cameraLoc - worldSpace.xyz;
				
				v_spot_surfaceToLight = vec3(5.0, 0.0, -2.0) - worldSpace.xyz;
				
				//idk
				// Adjust lighting for moon
				vec3 adjustedMoonDirection = normalize(moonDirection);
				fakenormal = RotateObject(a_position).xyz;
				v_surfaceToLight = adjustedMoonDirection;  // Directional light
				//end of idk
				
				fragColor = vert_color;
				vec4 cameraSpace = MoveCamera(worldSpace);
				
				gl_Position = ApplyProjection(cameraSpace);
				
				v_surfacePos = (PositionObject(RotateObject(ScaleObject(a_position)))).xyz;
			}		
		</SCRIPT>
		<script id="2dFragmentShader" type="notjs">
			precision mediump float;
			
			varying vec3 fragColor;
			
			varying vec3 fakenormal;
			varying vec3 v_surfaceToLight;
			varying vec3 v_surfaceToView;
			
			uniform vec3 p_lightPos[8];
			varying vec3 v_surfacePos;	

			varying vec3 v_spot_surfaceToLight;
			uniform vec3 v_spot_light_pos;
			uniform vec3 v_spot_light_direction;
			
			// directional
			uniform mediump vec3 moonDirection;
			
			void main()
			{
				//gl_FragColor = vec4(fragColor,1);
				
				float ambient = 0.1;

				/*float d_light = dot(normalize(fakenormal), normalize(vec3(20.0, 5.0, 20.0))* 0.25);
				if (d_light < 0.0) 
					d_light = 0.0;*/
					
				vec3 directional_light_direction = normalize(vec3(20.0, 5.0, 20.0));
				float d_light = dot(normalize(fakenormal), directional_light_direction);
				//vec3 normalizedNormal = normalize(fakenormal);
				//float d_light = max(dot(normalizedNormal, normalize(moonDirection)), 0.0);
				if (d_light < 0.0) {
					d_light = 0.0;
				}	
				d_light *= .15;

					//POINT LIGHT STUFF
				vec3 point_light = vec3(0.0);
				for (int i = 0; i < 8; i++) 
				{
					vec3 surfaceToPointLight = p_lightPos[i] - v_surfacePos;
					float p_light = dot(normalize(fakenormal), normalize(surfaceToPointLight)) * 2.0 / length(surfaceToPointLight);
					if (p_light < 0.0) 
						p_light = 0.0;
					point_light += p_light;
				}
				
				vec3 surfaceToLightVector = normalize(v_spot_light_pos - v_surfacePos);
				
				float cosAngleBetween = dot(surfaceToLightVector, -normalize(v_spot_light_direction));
				bool inSpotlightCone = cosAngleBetween > cos(0.98); 
				float spotEffect = inSpotlightCone ? pow(cosAngleBetween, 15.0) : 0.0;
				//float spotEffect = 0.0
				float distanceToLight = length(v_spot_light_pos - v_surfacePos);
				float attenuation = 1.0 / (1.0 + 0.09 * distanceToLight + 0.032 * distanceToLight * distanceToLight);
				float spotlightIntensity = spotEffect * attenuation;
				
				vec3 lightColor = vec3(1.0, 1.0, 1.0); // white light; change as needed
				vec3 spotlightContribution = lightColor * spotlightIntensity;

				
				vec3 surfaceToSpotlight = v_spot_light_pos - v_surfacePos;
				float spot_light = dot(normalize(surfaceToSpotlight), v_spot_light_direction); // inverse direction of spotlight
				float spot_light_power = 0.5;
				spot_light *= spot_light_power;
				
				/*if(spot_light >= 0.98)
				{
					spot_light_power = dot(normalize(fakenormal), normalize(v_spot_surfaceToLight));
					if(spot_light_power < 0.0)
						spot_light_power = 0.0;
				}*/
				
				gl_FragColor = vec4(fragColor * (ambient + d_light + point_light + spotlightContribution), 1.0);
			}
		</script>
		
		<script>
		class WebGL_Interface //webGL script
		{
			constructor()
			{
				this.vertexShaderSource = document.getElementById("2dVertexShader").text;
				this.fragmentShaderSource = document.getElementById("2dFragmentShader").text;
				this.vertexShader = this.createShader(gl.VERTEX_SHADER, this.vertexShaderSource);
				this.fragmenShader = this.createShader(gl.FRAGMENT_SHADER, this.fragmentShaderSource);

				this.program = this.createProgram(this.vertexShader,this.fragmenShader);

				gl.viewport(0,0, gl.canvas.width, gl.canvas.height);

				gl.clearColor(1,1,1,1);
				gl.clear(gl.COLOR_BUFFER_BIT);		
				gl.enable(gl.DEPTH_TEST);
				
				gl.useProgram(this.program);
				
			}
			
			createShader(type,source)
			{
				var shader = gl.createShader(type);
				gl.shaderSource(shader,source);
				gl.compileShader(shader);
				var success = gl.getShaderParameter(shader,gl.COMPILE_STATUS);
				if(success)
					return shader;
				console.error(gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);
			}
			
			createProgram(vs,fs)
			{
				var program = gl.createProgram();
				gl.attachShader(program,vs);
				gl.attachShader(program,fs);
				gl.linkProgram(program);
				var succsess = gl.getProgramParameter(program,gl.LINK_STATUS);
				if(succsess)
					return program;
				console.error(gl.getProgramInfoLog(program));
				gl.deleteProgram(program);
			}
		
		}
		</script>
		
		<script>
		class Transform //Object script
		{
			constructor()
			{
				this.forward = [0,0,1];
				this.right = [1,0,0];
				this.up = [0,1,0];
			}
		
			dorotations(RotAngles)
			{
				this.xRot = [
							[1,0,0,0],
							[0,Math.cos(RotAngles[0]),-1*Math.sin(RotAngles[0]),0],
							[0,Math.sin(RotAngles[0]),Math.cos(RotAngles[0]),0],
							[0,0,0,1]
						];		
				this.yRot = [
						[Math.cos(RotAngles[1]),0,Math.sin(RotAngles[1]),0],
						[0,1,0,0],
						[-1*Math.sin(RotAngles[1]),0,Math.cos(RotAngles[1]),0],
						[0,0,0,1]	
						];
				this.zRot = [
							[Math.cos(RotAngles[2]),-1*Math.sin(RotAngles[2]),0,0],
							[Math.sin(RotAngles[2]),Math.cos(RotAngles[2]),0,0],
							[0,0,1,0],
							[0,0,0,1]
						]		
				this.forward = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[0,0,1,0])))
				this.right = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[1,0,0,0])))
				this.up = this.crossMultiply(this.zRot,this.crossMultiply(this.yRot,this.crossMultiply(this.xRot,[0,1,0,0])))
			}			
			crossMultiply(M,V)
			{
			var temp = [
						M[0][0]*V[0]+M[0][1]*V[1]+M[0][2] * V[2]+ M[0][3]*V[3],
						M[1][0]*V[0]+M[1][1]*V[1]+M[1][2] * V[2]+ M[1][3]*V[3],
						M[2][0]*V[0]+M[2][1]*V[1]+M[2][2] * V[2]+ M[2][3]*V[3],
						M[3][0]*V[0]+M[3][1]*V[1]+M[3][2] * V[2]+ M[3][3]*V[3]
						]
				return temp;
			}
			
		}
		
		class GameObject
		{
			constructor() 
			{
				this.loc = [0, 0, 0];
				this.rot = [0, 0, 0];
				
				this.isTrigger = false;
				this.isPlayer = false;
				this.doDestroy = false;
				
				this.collisionRadius = 0.1;
				this.velocity = [0,0,0];
				this.angVelocity = [0,0,0];
				this.name = "Default";
				
				this.id = 0;
				this.transform = new Transform();
				this.prefab;
			}
			Move()
			{
				var tempP = [0, 0, 0];
				for(var i = 0; i < 3; i++)
				{
					tempP[i] = this.loc[i];
					tempP[i] += this.velocity[i];
					this.rot[i] += this.angVelocity[i];
				}
				var clear = true;
				for(var so in m.Solid) //for each
				{
					if(m.Solid[so] != this && !this.doDestroy && !m.Solid[so].doDestroy)
					{
						if(m.CheckCollision(tempP, this.collisionRadius, m.Solid[so].loc, m.Solid[so].collisionRadius))
						{		
							if(!this.isTrigger)
							{
								this.onCollisionEnter(m.Solid[so]);
								m.Solid[so].onCollisionEnter(this);
								clear = false;
							}
							else
							{
								m.Solid[so].onTriggerEnter(this);
								this.onTriggerEnter(m.Solid[so]); //Switched places in case player is destroyed
							}
						}
					}
				}
			
				if(clear)
					this.loc = tempP;
				for(var so in m.Trigger)
				{
					if(m.Trigger[so] != this && !this.doDestroy && !m.Trigger[so].doDestroy)
					{
						if(m.CheckCollision(this.loc, this.collisionRadius, m.Trigger[so].loc, m.Trigger[so].collisionRadius))
						{
							m.Trigger[so].onTriggerEnter(this);
							this.onTriggerEnter(m.Trigger[so]);
						}
					}
				}
			}
	
			Update()
			{
			
			}
			Render()
			{
				
			}
			onTriggerEnter(other)
			{
		
			}
			onCollisionEnter(other)
			{
			}
		}	

		//Camera Object
		class Camera extends GameObject
		{
			constructor()
			{
				super();
				this.isPlayer = true;
				//this.isTrigger = true;
				
				this.collisionRadius = 0.06;
				
				this.coolDown = 0;
			}
			Update()
			{
				//this.velocity = [0,0,0];
				//this.angVelocity = [0,0,0];
				
				if("E" in m.Keys && m.Keys["E"])
				{
					//this.angVelocity[1] -=.01;
					this.rot[1] +=.01;
				}
				if("Q" in m.Keys && m.Keys["Q"]) 
				{
					//this.angVelocity[1] +=.01;
					this.rot[1] -=.01;
				}
				
				this.velocity = [0,0,0];
				if("W" in m.Keys && m.Keys["W"])
				{
					this.transform.dorotations(this.rot);
					for(let i =0; i <3; i ++)
					{
						this.velocity[i] = this.transform.forward[i]*.01;
					}
				}
				if("S" in m.Keys && m.Keys["S"])
				{
					this.transform.dorotations(this.rot);
					for(let i =0; i <3; i ++)
					{
						this.velocity[i] = this.transform.forward[i]*-.01;
					}
				}
				
				if("A" in m.Keys && m.Keys["A"])
				{
					this.transform.dorotations(this.rot);
					for(let i =0; i <3; i ++)
					{
						this.velocity[i] = this.transform.right[i]*-.01;
					}
				}
				if("D" in m.Keys && m.Keys["D"])
				{
					this.transform.dorotations(this.rot);
					for(let i =0; i <3; i ++)
					{
						this.velocity[i] = this.transform.right[i]*.01;
					}
				}
				
				
				this.Move();
			}
			
			Render(program)
			{
				
				var camLoc = gl.getUniformLocation(program, 'cameraLoc');
				gl.uniform3fv(camLoc, new Float32Array(this.loc));
				
				var worldLoc = gl.getUniformLocation(program, 'cameraRotation');
				gl.uniform3fv(worldLoc, new Float32Array(this.rot));

			}
		}

		class Rock extends GameObject
		{
			constructor()
			{
				super();
				
				//this.isTrigger = true;
				
				this.startingX = this.loc[0];
				
				this.primitiveType = gl.TRIANGLES;
				this.collisionRadius = 1.3;
				this.buffer=gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				
				this.vertices = new Float32Array([
					// Position        Color
					0.0, 1, 0.0,  0.5, 0.5, 0.5, // red

					0.0, -1, 0.0,  0.5, 0.5, 0.5, // green

					1, 0.0, 0.0,  0.5, 0.5, 0.5, // blue

					-1, 0.0, 0.0,  0.5, 0.5, 0.5, // yellow

					0.0, 0.0, 1,  0.5, 0.5, 0.5, // magenta

					0.0, 0.0, -1,  0.5, 0.5, 0.5, // cyan
				]); 
					
				gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW);
						
				this.indexOrder = new Uint8Array([
					0, 2, 4,
					0, 4, 3,
					0, 3, 5,
					0, 5, 2,
					1, 4, 2,
					1, 3, 4,
					1, 5, 3,
					1, 2, 5
				]);
					
				this.ibuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.ibuffer);
				var count = this.indexOrder.length; // Number of indices
				var type = gl.UNSIGNED_BYTE; // Check the data type of your indices
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexOrder, gl.STATIC_DRAW);
			}
			
			Render(program)
			{
				var tranLoc  = gl.getUniformLocation(program,'transform');
				gl.uniform3fv(tranLoc,new Float32Array(this.loc));
				
				var thetaLoc = gl.getUniformLocation(program, "rotation");
				gl.uniform3fv(thetaLoc, new Float32Array(this.rot));
			
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		
				var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				var size = 3;          
				var type = gl.FLOAT;   
				var normalize = false; 
				var stride = 6*Float32Array.BYTES_PER_ELEMENT;	
				var offset = 0;      
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);
		
				var colorAttributeLocation = gl.getAttribLocation(program,"vert_color");

				size = 3;
				type = gl.FLOAT;
				normalize = false;
				stride = 6 * Float32Array.BYTES_PER_ELEMENT;	
				offset = 3 * Float32Array.BYTES_PER_ELEMENT;
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);
		
		
				var primitiveType = gl.TRIANGLES;
				offset = 0;
				var count = 12;
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
    
				gl.drawElements(this.primitiveType, this.indexOrder.length, gl.UNSIGNED_BYTE, 0);
			}
			
		}
		
		class Grass extends GameObject //solid
		{
			constructor()
			{
				super();
				
				//flat plane object
				this.buffer=gl.createBuffer();
				this.colorBuffer = gl.createBuffer();
				this.collisionRadius = 0.1;
		
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				this.vertices =
				[
					-1000,0,-1000,0,0.7,0,
					1000,0, -1000,0,0.7,0,
					-1000,0,1000,0,0.7,0,
					1000, 0,1000,0,0.7,0
				
				];
	
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
				//this.loc=[0,0,0];
				//this.rot=[0,0,0];
			}

			Render(program)
			{
				var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				var size = 3;          // 2 components per iteration
				var type = gl.FLOAT;   // the data is 32bit floats
				var normalize = false; // don't normalize the data
				var stride = 6*Float32Array.BYTES_PER_ELEMENT;	//Size in bytes of each element     // 0 = move forward size * sizeof(type) each iteration to get the next position
				var offset = 0;        // start at the beginning of the buffer
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);
		
				//Now we have to do this for color
				var colorAttributeLocation = gl.getAttribLocation(program,"vert_color");
				//We don't have to bind because we already have the correct buffer bound.
				size = 3;
				type = gl.FLOAT;
				normalize = false;
				stride = 6*Float32Array.BYTES_PER_ELEMENT;	//Size in bytes of each element
				offset = 3*Float32Array.BYTES_PER_ELEMENT;									//size of the offset
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);
				
				var tranLoc  = gl.getUniformLocation(program,'transform');
				gl.uniform3fv(tranLoc,new Float32Array(this.loc));
				var thetaLoc = gl.getUniformLocation(program,'rotation');
				gl.uniform3fv(thetaLoc,new Float32Array(this.rot));

				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			}
		}
		
		class Trunk extends GameObject
		{
			constructor()
			{
				super();
				this.collisionRadius = 0.1;
				this.primitiveType = gl.TRIANGLES;
				
				// Create buffer for vertex data
				this.buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

				// Define colors
				const brown = [0.54, 0.27, 0.07]; // Brown color for the trunk

				// Create trunk vertices with interleaved color data
				const trunkVertices = new Float32Array([
					-0.05, -0.5, 0.05, ...brown, 
					0.05, -0.5, 0.05, ...brown,  
					-0.05, 0.5, 0.05, ...brown,  
					0.05, 0.5, 0.05, ...brown,   
					-0.05, -0.5, -0.05, ...brown,
					0.05, -0.5, -0.05, ...brown, 
					-0.05, 0.5, -0.05, ...brown,
					0.05, 0.5, -0.05, ...brown  
				]);

				gl.bufferData(gl.ARRAY_BUFFER, trunkVertices, gl.STATIC_DRAW);

				// Define indices for drawing the icosahedron
				this.indexOrder = new Uint8Array([
					// Front face
					0, 1, 2, 2, 1, 3,
					// Back face
					4, 5, 6, 6, 5, 7,
					// Top face
					1, 5, 3, 3, 5, 7,
					// Bottom face
					0, 4, 2, 2, 4, 6,
					// Right face
					2, 6, 3, 3, 6, 7,
					// Left face
    				0, 1, 4, 4, 1, 5
				]);

				// Create buffer for indices
				this.ibuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexOrder, gl.STATIC_DRAW);
			}
			
			Render(program)
			{
				var tranLoc  = gl.getUniformLocation(program,'transform');
				gl.uniform3fv(tranLoc,new Float32Array(this.loc));
				
				var thetaLoc = gl.getUniformLocation(program, "rotation");
				gl.uniform3fv(thetaLoc, new Float32Array(this.rot));
			
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		
				var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				var size = 3;          
				var type = gl.FLOAT;   
				var normalize = false; 
				var stride = 6*Float32Array.BYTES_PER_ELEMENT;	
				var offset = 0;      
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, size, type, false, stride, offset);
		
				var colorAttributeLocation = gl.getAttribLocation(program,"vert_color");

				offset = 3 * Float32Array.BYTES_PER_ELEMENT;
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, size, type, false, stride, offset);
		
		
				var primitiveType = gl.TRIANGLES;
				offset = 0;
				var count = 36;
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
    
				gl.drawElements(this.primitiveType, count, gl.UNSIGNED_BYTE, 0);
			}
		}
		
		class Leaves extends GameObject
		{
			constructor()
			{
				super();
				this.collisionRadius = 0.08;
				this.primitiveType = gl.TRIANGLES;
				
				// Create buffer for vertex data
				this.buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);

				// Define colors
				const green = [0.0, 1.0, 0.0]; // Green for leaves
				
				const X = 0.525731112119133606;
				const Z = 0.850650808352039932;

				// Create icosahedron vertices with interleaved color data
				const vertices = new Float32Array([
					-X, 0.0, Z, ...green,
					X, 0.0, Z, ...green,
					-X, 0.0, -Z, ...green,
					X, 0.0, -Z, ...green,
					0.0, Z, X, ...green,
					0.0, Z, -X, ...green,
					0.0, -Z, X, ...green,
					0.0, -Z, -X, ...green,
					Z, X, 0.0, ...green,
					-Z, X, 0.0, ...green,
					Z, -X, 0.0, ...green,
					-Z, -X, 0.0, ...green
				]);
				

				// Define indices for drawing the icosahedron
				this.indexOrder = new Uint8Array([
					0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
					1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
					3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
					4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
				]);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

				// Create buffer for indices
				this.ibuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexOrder, gl.STATIC_DRAW);
			}
			Render(program)
			{
				var tranLoc  = gl.getUniformLocation(program,'transform');
				gl.uniform3fv(tranLoc,new Float32Array(this.loc));
				
				var thetaLoc = gl.getUniformLocation(program, "rotation");
				gl.uniform3fv(thetaLoc, new Float32Array(this.rot));
			
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		
				var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				var size = 3;          
				var type = gl.FLOAT;   
				var normalize = false; 
				var stride = 6*Float32Array.BYTES_PER_ELEMENT;	
				var offset = 0;      
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, size, type, false, stride, offset);
		
				var colorAttributeLocation = gl.getAttribLocation(program,"vert_color");

				offset = 3 * Float32Array.BYTES_PER_ELEMENT;
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, size, type, false, stride, offset);
		
		
				var primitiveType = gl.TRIANGLES;
				offset = 0;
				var count = this.indexOrder.length;
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
    
				gl.drawElements(this.primitiveType, count, gl.UNSIGNED_BYTE, 0);
			}
		}
		
		class SphereLeaves extends GameObject 
		{
			constructor() 
			{
				super();
				this.size = 1;
				this.segments = 32;
  
				const { vertices, normals, indices } = this.generateSphereData(
					this.size,
					this.segments
				);
  
				const vertexData = [];
				for (let i = 0; i < vertices.length / 3; i++) {
					vertexData.push(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);
					vertexData.push(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
					vertexData.push(0.0, 0.8, 0.0); // set color
				}
				this.buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.STATIC_DRAW);
  
				this.indexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
				
				this.scale = [1,1,1];
			}
  
			generateSphereData(radius, segments) 
			{
				const vertices = [];
				const normals = [];
				const indices = [];
  
					for (let y = 0; y <= segments; y++) 
					{
						for (let x = 0; x <= segments; x++) 
						{
							const xSegment = x / segments;
							const ySegment = y / segments;
  
							const xPos = radius * Math.sin(ySegment * Math.PI) * Math.cos(xSegment * 2 * Math.PI);
							const yPos = radius + 1 * Math.cos(ySegment * Math.PI);
							const zPos = radius * Math.sin(ySegment * Math.PI) * Math.sin(xSegment * 2 * Math.PI);
  
							vertices.push(xPos, yPos, zPos);
							normals.push(xPos, yPos, zPos);
  
							if (x < segments && y < segments) 
							{
								const first = y * (segments + 1) + x;
								const second = first + segments + 1;
  
								indices.push(first, second, first + 1);
								indices.push(second, second + 1, first + 1);
							}
						}
					}
  
				return {vertices, normals, indices};
			}
  
			Render(program) 
			{
				var tranLoc  = gl.getUniformLocation(program,'transform');
				gl.uniform3fv(tranLoc,new Float32Array(this.loc));
				
				var thetaLoc = gl.getUniformLocation(program, "rotation");
				gl.uniform3fv(thetaLoc, new Float32Array(this.rot));
				
				var scaleLoc = gl.getUniformLocation(program, 'scale');
				gl.uniform3fv(scaleLoc, new Float32Array(this.scale));
				// Bind buffer and set up attributes
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
  
				const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 9 * Float32Array.BYTES_PER_ELEMENT, 0);
  

				const colorAttributeLocation = gl.getAttribLocation(program, "vert_color");
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 9 * Float32Array.BYTES_PER_ELEMENT, 6 * Float32Array.BYTES_PER_ELEMENT);
  
				// Bind index buffer and draw elements
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
				const count = this.segments * this.segments * 6; // Update count to match total indices
				gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, 0);
			}
		}
		
		// Uses trunk and leaves
		class Tree1 extends GameObject
		{
			constructor()
			{
				super();
				this.collisionRadius = 0.1;
				this.trunk = new Trunk;
				
				let whichTree = Math.floor((Math.random() * 2) + 1);
				
				if(whichTree > 1)
					this.leaves = new Leaves;
				else
					this.leaves = new SphereLeaves;
				
			}
			Render(program)
			{
				this.trunk.loc[0] = this.loc[0];
				this.trunk.loc[1] = this.loc[1];
				this.trunk.loc[2] = this.loc[2];
				
				this.leaves.loc[0] = this.trunk.loc[0];
				this.leaves.loc[1] = this.trunk.loc[1] + 0.55;
				this.leaves.loc[2] = this.trunk.loc[2];
				
				this.trunk.Render(program);
				this.leaves.Render(program);
			}
		}
		
		class PointLight extends GameObject 
		{
			static count = 0;

			constructor() 
			{
				super();
				this.loc = [0, 0, 0];
				this.intensity = 8.0;
				this.index = PointLight.count;
				PointLight.count++;
			}

			setUniforms(gl, program) 
			{
				const pointLightPositionLocation = gl.getUniformLocation(program, "p_lightPos[" + this.index + "]");
				const pointLightIntensityLocation = gl.getUniformLocation(program, "u_pointLightIntensity");
	  
				gl.uniform3fv(pointLightPositionLocation, new Float32Array(this.loc));
				gl.uniform1f(pointLightIntensityLocation, this.intensity);
			}

			Render(program) 
			{
				this.setUniforms(gl, program);
			}
		}
		
		class Spotlight extends GameObject 
		{
			constructor(moveAlongXAxis, moveAlongZAxis) 
			{
				super();
				this.loc = [0, 0, 0];
				this.rot = [Math.PI/2, 0, 0]; // Set the pitch rotation to -90 degrees (-π/2 radians)
				this.position = this.loc;
				this.direction = this.directionFromRotation(this.rot);
				this.intensity = 2; 
				this.angle = Math.PI / 4; // Hardcoded angle value
				this.collisionRadius = 1.5;

				this.velocity[0] = 0.5;
				this.velocity[1] = 0
				this.velocity[2] = 0.5;
			}

			directionFromRotation(rot) 
			{
				const pitch = rot[0];
				const yaw = rot[1];
	  
				const x = Math.cos(pitch) * Math.cos(yaw);
				const y = Math.sin(pitch);
				const z = Math.cos(pitch) * Math.sin(yaw);
	  
				return [x, y, z];
			}

			setUniforms(gl, program) 
			{
				//console.log("set");
				const spotlightPositionLocation = gl.getUniformLocation(program, "v_spot_light_pos");
				const spotlightDirectionLocation = gl.getUniformLocation(program, "v_spot_light_direction");
	  
				gl.uniform3fv(spotlightPositionLocation, new Float32Array(this.loc));
				gl.uniform3fv(spotlightDirectionLocation, new Float32Array(this.direction));
			}
			/*Update() 
			{
				// Update position based on velocity
				for (let i = 0; i < 3; i++) 
				{
					this.loc[i] += this.velocity[i];
				}
    
				// Randomly change direction occasionally
				if (Math.random() < 0.1) 
				{
					this.velocity[0] = Math.random() * 0.5 - 0.25; // Random X velocity between -0.25 and 0.25
					this.velocity[2] = Math.random() * 0.5 - 0.25; // Random Z velocity between -0.25 and 0.25
				}
    
				// Keep within bounds, reverse direction if out of bounds
				if (this.loc[0] < -80 || this.loc[0] > 80) {
					this.velocity[0] = -this.velocity[0];
				}
				if (this.loc[2] < -80 || this.loc[2] > 80) {
					this.velocity[2] = -this.velocity[2];
				}

				console.log("Light is at: " + this.loc[0] + ", " + this.loc[1] + ", " + this.loc[2]);
				
			}*/
  
			Render(program) 
			{
				this.setUniforms(gl, program);
			}
		}
		
		class Lantern extends GameObject
		{
			constructor()
			{
				super();
				this.collisionRadius = 0.09;
				this.primitiveType = gl.TRIANGLES;
				
				// Create buffer for vertex data
				this.buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				
				const white = [1.0, 1.0, 1.0];
				const navy = [0.05, 0.0, 0.4];
				
				 const heightOffset = 0.2;
				
				const centerCube = new Float32Array([
					-0.1, -0.1, 0.1, ...white, 
					0.1, -0.1, 0.1, ...white,  
					-0.1, 0.1, 0.1, ...white,  
					0.1, 0.1, 0.1, ...white,   
					-0.1, -0.1, -0.1, ...white,
					0.1, -0.1, -0.1, ...white, 
					-0.1, 0.1, -0.1, ...white,
					0.1, 0.1, -0.1, ...white  
				]);
				
				const topCube = new Float32Array([
					-0.12, -0.03, 0.12, ...navy, 
					0.12, -0.03, 0.12, ...navy,  
					-0.12, 0.03, 0.12, ...navy,  
					0.12, 0.03, 0.12, ...navy,   
					-0.12, -0.03, -0.12, ...navy,
					0.12, -0.03, -0.12, ...navy, 
					-0.12, 0.03, -0.12, ...navy,
					0.12, 0.03, -0.12, ...navy  
				]);
				
				const bottomCube = new Float32Array([
					-0.12, -0.03, 0.12, ...navy, 
					0.12, -0.03, 0.12, ...navy,  
					-0.12, 0.03, 0.12, ...navy,  
					0.12, 0.03, 0.12, ...navy,   
					-0.12, -0.03, -0.12, ...navy,
					0.12, -0.03, -0.12, ...navy, 
					-0.12, 0.03, -0.12, ...navy,
					0.12, 0.03, -0.12, ...navy  
				]);
				
				 for (let i = 1; i < topCube.length; i += 6) 
				 {
					topCube[i + 3] += heightOffset; // For the Y coordinate
					bottomCube[i + 3] -= heightOffset; // For the Y coordinate
				}
				 
				 const vertices = new Float32Array([...centerCube, ...topCube, ...bottomCube]);
				 
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);


				// Define indices for the center cube
				const centerIndices = [
					// Front face
					0, 1, 2, 2, 1, 3,
					// Back face
					4, 5, 6, 6, 5, 7,
					// Top face
					1, 5, 3, 3, 5, 7,
					// Bottom face
					0, 4, 2, 2, 4, 6,
					// Right face
					2, 6, 3, 3, 6, 7,
					// Left face
    				0, 1, 4, 4, 1, 5
				];

				// Offset for top cube indices (assuming 8 vertices per cube, adjust if different)
				const topCubeIndexOffset = 8;

				// Offset for bottom cube indices (assuming 16 vertices by this point)
				const bottomCubeIndexOffset = 16;

				// Calculate the indices for the top and bottom cubes
				const topIndices = centerIndices.map(index => index + topCubeIndexOffset);
				const bottomIndices = centerIndices.map(index => index + bottomCubeIndexOffset);

				const indices = new Uint8Array([...centerIndices, ...topIndices, ...bottomIndices]);

				// Create buffer for indices
				this.ibuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
			}
			
			Render(program)
			{
				var tranLoc  = gl.getUniformLocation(program,'transform');
				gl.uniform3fv(tranLoc,new Float32Array(this.loc));
				
				var thetaLoc = gl.getUniformLocation(program, "rotation");
				gl.uniform3fv(thetaLoc, new Float32Array(this.rot));
			
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		
				var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				var size = 3;          
				var type = gl.FLOAT;   
				var normalize = false; 
				var stride = 6*Float32Array.BYTES_PER_ELEMENT;	
				var offset = 0;      
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, size, type, false, stride, offset);
		
				var colorAttributeLocation = gl.getAttribLocation(program,"vert_color");

				offset = 3 * Float32Array.BYTES_PER_ELEMENT;
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, size, type, false, stride, offset);
		
		
				var primitiveType = gl.TRIANGLES;
				offset = 0;
				var count = 36 * 3;
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
    
				gl.drawElements(this.primitiveType, count, gl.UNSIGNED_BYTE, 0);
			}
		}
		
		class Goal extends GameObject
		{
			constructor()
			{
				super();
				this.collisionRadius = 2
				
				this.primitiveType = gl.TRIANGLES;
				this.isTrigger = true;
				
				// Create buffer for vertex data
				this.buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				
				const yellow = [0.8, 0.7, 0]; // kinda yellow gold
				
				this.vertices = new Float32Array([
					-1.0, -1.0, 1.0, ...yellow, 
					1.0, -1.0, 1.0, ...yellow,  
					-1.0, 1.0, 1.0, ...yellow,  
					1.0, 1.0, 1.0, ...yellow,   
					-1.0, -1.0, -1.0, ...yellow,
					1.0, -1.0, -1.0, ...yellow, 
					-1.0, 1.0, -1.0, ...yellow,
					1.0, 1.0, -1.0, ...yellow 
				]);
				
				gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW);
				
				this.indexOrder = new Uint8Array([
					// Front face
					0, 1, 2, 2, 1, 3,
					// Back face
					4, 5, 6, 6, 5, 7,
					// Top face
					1, 5, 3, 3, 5, 7,
					// Bottom face
					0, 4, 2, 2, 4, 6,
					// Right face
					2, 6, 3, 3, 6, 7,
					// Left face
    				0, 1, 4, 4, 1, 5
				]);
				
				this.ibuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,this.ibuffer);
				var count = this.indexOrder.length; // Number of indices
				var type = gl.UNSIGNED_BYTE; // Check the data type of your indices
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexOrder, gl.STATIC_DRAW);
			}
			Render(program)
			{
				var tranLoc  = gl.getUniformLocation(program,'transform');
				gl.uniform3fv(tranLoc,new Float32Array(this.loc));
				
				var thetaLoc = gl.getUniformLocation(program, "rotation");
				gl.uniform3fv(thetaLoc, new Float32Array(this.rot));
				
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
		
				var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				var size = 3;          
				var type = gl.FLOAT;   
				var normalize = false; 
				var stride = 6*Float32Array.BYTES_PER_ELEMENT;	
				var offset = 0;      
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, size, type, false, stride, offset);
		
				var colorAttributeLocation = gl.getAttribLocation(program,"vert_color");

				offset = 3 * Float32Array.BYTES_PER_ELEMENT;
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, size, type, false, stride, offset);
		
		
				var primitiveType = gl.TRIANGLES;
				offset = 0;
				var count = 36;
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.ibuffer);
    
				gl.drawElements(this.primitiveType, count, gl.UNSIGNED_BYTE, 0);
			}
			
			onTriggerEnter(other)
			{
				if(other.isPlayer == true)
				{
					m.winText.innerHTML = "YOU ESCAPED SPOOPY DARK FOREST";
					
					//Destroy the monster and spot light
				}
			}
		}
		
		class Moon extends GameObject 
		{
			constructor() 
			{
				super();
				this.size = 1;
				this.segments = 32;
  
				const { vertices, normals, indices } = this.generateSphereData(
					this.size,
					this.segments
				);
  
				const vertexData = [];
				for (let i = 0; i < vertices.length / 3; i++) {
					vertexData.push(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]);
					vertexData.push(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);
					vertexData.push(1.0, 1.0, 1.0); // set color
				}
				this.buffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.STATIC_DRAW);
  
				this.indexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
				
				this.scale = [1,1,1];
				
				this.calculateOrientation();
			}
			
			calculateOrientation() {
        const forward = [0, 0, -1];  // Default forward vector
        const target = [20, 5, 20];
        const normalizedTarget = this.normalize(target);

        const axis = this.cross(forward, normalizedTarget);
        const angle = Math.acos(this.dot(forward, normalizedTarget));

        this.rot = this.rotationFromAxisAngle(axis, angle); // Apply this rotation
    }

    normalize(v) {
        const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        return [v[0] / length, v[1] / length, v[2] / length];
    }

    cross(v1, v2) {
        return [
            v1[1] * v2[2] - v1[2] * v2[1],
            v1[2] * v2[0] - v1[0] * v2[2],
            v1[0] * v2[1] - v1[1] * v2[0]
        ];
    }

    dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }

    rotationFromAxisAngle(axis, angle) {
        // This is a simplified example, assuming WebGL or similar utilities for matrix manipulation
        // You might need to implement or use a library function to convert axis-angle to a quaternion or rotation matrix
        return [axis[0] * angle, axis[1] * angle, axis[2] * angle];  // Simplified placeholder
    }
  
			generateSphereData(radius, segments) 
			{
				const vertices = [];
				const normals = [];
				const indices = [];
  
					for (let y = 0; y <= segments; y++) 
					{
						for (let x = 0; x <= segments; x++) 
						{
							const xSegment = x / segments;
							const ySegment = y / segments;
  
							const xPos = radius * Math.sin(ySegment * Math.PI) * Math.cos(xSegment * 2 * Math.PI);
							const yPos = radius + 1 * Math.cos(ySegment * Math.PI);
							const zPos = radius * Math.sin(ySegment * Math.PI) * Math.sin(xSegment * 2 * Math.PI);
  
							vertices.push(xPos, yPos, zPos);
							normals.push(xPos, yPos, zPos);
  
							if (x < segments && y < segments) 
							{
								const first = y * (segments + 1) + x;
								const second = first + segments + 1;
  
								indices.push(first, second, first + 1);
								indices.push(second, second + 1, first + 1);
							}
						}
					}
  
				return {vertices, normals, indices};
			}
  
			Render(program) 
			{
				var tranLoc  = gl.getUniformLocation(program,'transform');
				gl.uniform3fv(tranLoc,new Float32Array(this.loc));
				
				var thetaLoc = gl.getUniformLocation(program, "rotation");
				gl.uniform3fv(thetaLoc, new Float32Array(this.rot));
				
				var scaleLoc = gl.getUniformLocation(program, 'scale');
				gl.uniform3fv(scaleLoc, new Float32Array(this.scale));
				
				// new direction code
				
				var dirLoc = gl.getUniformLocation(program, 'moonDirection');
				
				gl.uniform3fv(dirLoc, new Float32Array([-1, -1, -1]));  // Example direction
				
				// Bind buffer and set up attributes
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
  
				const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 9 * Float32Array.BYTES_PER_ELEMENT, 0);
  

				const colorAttributeLocation = gl.getAttribLocation(program, "vert_color");
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 9 * Float32Array.BYTES_PER_ELEMENT, 6 * Float32Array.BYTES_PER_ELEMENT);
  
				// Bind index buffer and draw elements
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
				const count = this.segments * this.segments * 6; // Update count to match total indices
				gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, 0);
			}
		}
		
		</script>
		
		<script>
		class main
		{	
			constructor()
			{
				this.Visual = [];
				this.Solid = [];
				this.Trigger = [];
				this.ObjectCounter = 0;
			
				this.myWEBGL = new WebGL_Interface();
				this.program = this.myWEBGL.program;
				this.myTriangle = [];
				this.Keys = [];
				
				// Text to change when you win
				this.winSection = document.getElementById("winSec"); 
				this.winText = document.getElementById("winTxt"); 
				
				var camLoc = gl.getUniformLocation(this.program, 'cameraLoc');
				gl.uniform3fv(camLoc, new Float32Array([0,0,0]));
				var worldLoc = gl.getUniformLocation(this.program, 'cameraRotation');
				gl.uniform3fv(worldLoc, new Float32Array([0,0,0]));
				
				var tempLoc = gl.getUniformLocation(this.program,'n');
				gl.uniform1f(tempLoc,.1);
				tempLoc = gl.getUniformLocation(this.program,'f');
				gl.uniform1f(tempLoc,500);
				tempLoc = gl.getUniformLocation(this.program,'r');
				gl.uniform1f(tempLoc,.1);
				tempLoc = gl.getUniformLocation(this.program,'t');
				gl.uniform1f(tempLoc,.1 * 3/4);
			
				this.CreateObject(0,Grass,[0,-1,0],[0,0,0]);
				
				this.Player = this.CreateObject(1,Camera,[0,0,0],[0,0,0]);
				
				// moon
				this.CreateObject(0,Moon,[0,15,-5],[0,0,0]);
				
				// spot light
				this.CreateObject(2, Spotlight, [0, 6, 0], [0,0,0]);
				
				// Create goal
				let posX = Math.floor((Math.random() * 40) + 30);
				let posZ = Math.floor((Math.random() * 98) - 60);
				
				this.CreateObject(2, Goal, [posX, 0, posZ], [0,0,0]);
				this.CreateObject(0, PointLight, [posX, 3, posZ], [0,0,0]);
				
				function generateRandomPosition() {
					let value = (Math.random() * 20) + 30; // Generates a random number between 30 and 50
					return Math.random() < 0.5 ? value : -value; // Randomly decides if the value should be positive or negative
				}
				
				// Create point lights
				for(let i = 0; i < 7; i++)
				{
					let posX = generateRandomPosition();
					let posZ = generateRandomPosition();
					this.CreateObject(0, PointLight, [posX, 0, posZ], [0,0,0]);
					this.CreateObject(1, Lantern, [posX, -0.5, posZ], [0,0,0]);
				}
				
				// Generate 150 rocks and trees
				
				for(let i = 0; i < 100; i++)
				{
					
					
					let posX = Math.floor((Math.random() * 101) - 50);
					let posZ = Math.floor((Math.random() * 101) - 50);
					
					let rotX = Math.floor((Math.random() * 5) - 2);
					let rotY = Math.floor((Math.random() * 11) - 10);
					
					this.CreateObject(1,Rock,[posX,0,posZ],[rotX,rotY,0]);
				}
				
				// Another 200 trees
				for(let i = 0; i < 280; i++)
				{
					let posX = Math.floor((Math.random() * 101) - 50);
					let posZ = Math.floor((Math.random() * 101) - 50);
					
					this.CreateObject(1,Tree1,[posX,0,posZ],[0,0,0]);
				}
				
			}
			
			UpdateAll()
			{
				for(var i in this.Visual)
				{
					this.Visual[i].Update();
				}
				for(var i in this.Solid)
				{
					this.Solid[i].Update();
				}
				for(var i in this.Trigger)
				{
					this.Trigger[i].Update();
				}
			}

			RenderAll()
			{
				gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
				
				
				for(var i in this.Visual)
				{
					this.Visual[i].Render(this.program);
				}
				for(var i in this.Solid)
				{
					this.Solid[i].Render(this.program);
				}
				for(var i in this.Trigger)
				{
					this.Trigger[i].Render(this.program);
				}			
			}
			
			CheckCollision(loc1,rad1,loc2, rad2)
			{
				var distance = Math.sqrt((loc2[0] - loc1[0]) ** 2 + (loc2[1] - loc1[1]) ** 2 + (loc2[2] - loc1[2]) ** 2);
				return distance < (rad1 + rad2);
			}
			
			CreateObject(type, prefab, loc, rot)
			{
				//type 0 = visual, type 1 = solid, type 2 = trigger
				var temp= new prefab;
				var id = "ID" + this.ObjectCounter;
				this.ObjectCounter ++;
				temp.id = id;
				temp.prefab = prefab;
				
				for (let i = 0; i < 3; i++)
				{
					temp.loc[i] = loc[i];
					temp.rot[i] = rot[i];

				}

				switch(type)
				{
					case 0:
						this.Visual[id] = temp;
						break;
					case 1:
						this.Solid[id] = temp;
						break;
					case 2:
						temp.isTrigger = true;
						this.Trigger[id] = temp;
						break;
					default:
						break;
				}
			
				return temp;
			}
			DestroyObject(id)
			{
				if (id in this.Visual)
					delete this.Visual[id];
				if (id in this.Solid)
					delete this.Solid[id];
				if (id in this.Trigger)
				{
					console.log("Deleting: " + this.Trigger[id].name);
					delete this.Trigger[id];
				}
			}
			
			KeyDown(event)
			{
				this.Keys[String.fromCharCode(event.keyCode)] = true;
			}
			
			KeyUp(event)
			{
				this.Keys[String.fromCharCode(event.keyCode)] = false;
			}

			TestKey(test)
			{
				if (test in this.Keys)
					return this.Keys[test];
				return false;
			}

			static keyD(event)
			{
				m.KeyDown(event);
			}

			static keyU(event)
			{
				m.KeyUp(event);
			}
			
			static MainLoop()
			{
				m.UpdateAll();
				m.RenderAll();
				requestAnimationFrame(main.MainLoop);
			}
		}	
		</script>
	</Head>
	<BODY style="padding: 15px;">
		<HEADER>
			<h1>Spoopy Dark Forest !!!</h1>
			
			<section id="winSec">
				<p id="winTxt" style="font-size: 25px;"></p>
			</section>
		</HEADER>
		
		<CANVAS id="myCanvas" width="640" height="640" style = "border: 1px solid #000;">
			Your browser does not support canvas.
		</CANVAS>
		
		<SCRIPT>
			var canvas = document.getElementById("myCanvas");
			var gl = canvas.getContext("webgl");
			var m = new main();
			window.onkeydown = main.keyD;
			window.onkeyup = main.keyU;
			
			requestAnimationFrame(main.MainLoop);	
			
		</SCRIPT>
	</BODY>
</HTML>
